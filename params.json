{"name":"Evactor","body":"Evactor\r\n=====================\r\n***Check out the [example](https://github.com/aorwall/evactor/tree/master/example) module to get a better understanding on how all this works.***\r\n\r\nThis is an attempt to create a complex event processing implementation in Akka. The idea is that *processors* subscribe to *channels* to receive *events* published on the channels. The event processor can then process the events in some way and publish new events on other event channels. \r\n\r\nThe project also houses a storage solution, based on Apache Cassandra, for auditing and statistics. An API exists for easy access to historic data.\r\n\r\n\r\nFlow\r\n---------------------\r\n\r\n### Event\r\n*TODO*\r\n\r\n### Collector\r\nA *collector* collects events from external event producers. \r\n\r\n### Processor\r\nA processor is a component that performs operations on events. This could be to extract data, create new events based on aggregated events or examining a collection of events to find a particular pattern.\r\n\r\nTo receive events the processor subscribes to channels or to all events that flows through the system. When the processor creates a new event it can publish it to another channel.\r\n\r\n### Channel\r\n*TODO*\r\n\r\n\r\nConfiguration\r\n---------------------\r\nEverything is configured in the `application.conf` file.\r\n\r\n### Collectors\r\n*TODO*\r\n\r\n### Processors\r\n\r\n#### Routers\r\nHandles routing in the system\r\n\r\n##### Forwarder\r\nJust forwarding an event to a different channel (and category)\r\n\r\n###### Configuration\r\n```text\r\nforwarderName {\r\n  type = forwarder\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" }\r\n}\r\n```\r\n\r\n##### Filter\r\nFiltering out events that doesn't comply with a specified rule(expression)\r\n\r\n###### Configuration\r\n```text\r\nfilterName {\r\n  type = filter\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" } \r\n  expression = { mvel = \"value > 0\" }\r\n  accept = false\r\n}\r\n```\r\n\r\n#### Analysers\r\nAnalysing sequences of events and produces new events with the result \r\n\r\n##### Count analyser\r\nCounts events within a specified time frame\r\n\r\n###### Configuration\r\n```text\r\nfilterName {\r\n  type = countAnalyser\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" } \r\n  categorize = true\r\n  timeframe = 2 hours\r\n}\r\n```\r\n##### Average analyser\r\nCount average in a specified window (time or length)\r\n\r\n###### Configuration\r\n```text\r\naverageAnalyserName {\r\n  type = averageAnalyser\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" }\r\n  categorize = false\r\n  expression = { static = \"foo\" }\r\n  window = { time = 1 minute }\r\n}\r\n```\r\n##### Regression analyser\r\nCalculates the regression coefficient within a specified time frame\r\n\r\n###### Configuration\r\n```text\r\nregressionName {\r\n  type = regressionAnalyser\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" } \r\n  categorize = true\r\n  minSize = 25\r\n  timeframe = 15 minutes\r\n}\r\n```\r\n\r\n#### Alerter\r\nAlerts when events that doesn't comply with a specified rule(expression) and informs when state is back to normal.\r\n\r\n```text\r\n  type = alerter\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" } \r\n  categorize = false\r\n  expression = { mvel = \"true\" }\r\n```\r\n\r\n#### Builders\r\n*TODO*\r\n\r\n#### Producers\r\nProduces events to external consumers.\r\n\r\n##### LogProducers\r\nWrites events to log.\r\n\r\n###### Configuration\r\n```text\r\nlogger {\r\n  type = logProducer\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  loglevel = INFO\r\n}\r\n```\r\n\r\n#### Custom processor\r\nIt's possible to create a custom processor and use it in the configuration by specifying the class instead of *type*.\r\n\r\n##### Configuration\r\n```text\r\ncustomProcessor {\r\n  class = org.example.CustomProcessor\r\n  subscriptions = [ {channel = \"foo\"} ]\r\n  publication = { channel = \"bar\" } \r\n  arguments = [\"foo\", \"bar\"]\r\n}\r\n```\r\n\r\n##### Example implementation\r\n```scala\r\n\r\nclass SimpleProcessor (\r\n    override val subscriptions: List[Subscription],\r\n    val publication: Publication)\r\n  extends Processor(subscriptions) with Publisher {\r\n\r\n  def process(event: Event) {\r\n    // do stuff\r\n\r\n    publish(event)\r\n  }\r\n}\r\n\r\n```\r\n\r\n\r\nStorage\r\n---------------------\r\n*TODO*\r\n\r\nAPI\r\n---------------------\r\n*TODO*\r\n\r\nBuild and deploy\r\n---------------------\r\n*TODO*\r\n\r\nLicence\r\n---------------------\r\nCopyright 2012 Albert Ã–rwall\r\n\r\nLicensed under the Apache License, Version 2.0: http://www.apache.org/licenses/LICENSE-2.0","tagline":"Complex event processor based on Akka","google":"UA-31879466-1","note":"Don't delete this file! It's used internally to help with page regeneration."}